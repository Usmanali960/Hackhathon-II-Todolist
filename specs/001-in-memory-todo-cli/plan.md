# Implementation Plan: Hackathon II Phase I - In-Memory Todo Application (CLI)

**Branch**: `001-in-memory-todo-cli` | **Date**: 2025-12-31 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/001-in-memory-todo-cli/spec.md`

**Note**: This template is filled in by `/sp.plan` command. See `.specify/templates/commands/plan.md` for the execution workflow.

## Summary

Implement a complete in-memory Python CLI todo application supporting core CRUD operations, task organization (priorities, tags, search, filter, sort), and advanced features (due dates, reminders, recurring tasks). The system uses Python 3.13+ with standard library only, storing all tasks in memory with no persistence. Design follows modular principles with clear separation between domain logic, CLI interface, and task operations, preparing for future phases to add persistence, web UI, and AI integration.

## Technical Context

**Language/Version**: Python 3.13+
**Primary Dependencies**: Standard library only, UV for dependency management
**Storage**: In-memory (no database, no files)
**Testing**: Python unittest framework (standard library)
**Target Platform**: Linux/Windows/macOS (any platform with Python 3.13+)
**Project Type**: Single (CLI application)
**Performance Goals**: 100 tasks CRUD in under 1 second, 100 tasks search/filter/sort in under 1 second, reminder notifications within 5 seconds of due time
**Constraints**: No external dependencies beyond UV package manager, no persistence, no network operations, no background services
**Scale/Scope**: In-memory storage, supporting hundreds of tasks maximum during single runtime session

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Constitution Principle | Status | Justification |
|---------------------|---------|----------------|
| No Manual Application Code | ✅ PASS | All application code will be generated by Claude Code based on this plan and tasks |
| Specification-First | ✅ PASS | Plan directly traces to spec.md requirements FR-001 through FR-030 |
| Claude Code as Sole Executor | ✅ PASS | Only Claude Code will generate implementation code from tasks.md |
| Single Source of Truth | ✅ PASS | spec.md is authoritative; all design decisions reference spec sections |
| No Vibe Coding | ✅ PASS | Every architectural decision is documented and traceable to requirements |
| Incremental Validation | ✅ PASS | Each plan step delivers testable functionality before proceeding |
| Core Stack: Python 3.13+ | ✅ PASS | Aligned with constitution Phase I technology stack |
| No External Dependencies | ✅ PASS | Using standard library only, UV only for package management |
| Forbidden: Databases, Web Frameworks | ✅ PASS | Spec explicitly excludes these; plan uses in-memory only |
| Clean Folder Structure | ✅ PASS | Plan defines clear module separation (models, services, cli) |
| Modular Design | ✅ PASS | Components are small, focused, loosely coupled (see architecture) |
| Stateless Backend Philosophy | ✅ PASS | While CLI is in-memory, design separates state for future persistence layers |
| Production-Grade Engineering | ✅ PASS | Error handling, validation, and input sanitization planned from start |

**Result**: All gates passed. Proceeding to Phase 0 research.

## Project Structure

### Documentation (this feature)

```text
specs/001-in-memory-todo-cli/
├── plan.md              # This file (/sp.plan command output)
├── research.md          # Phase 0 output
├── data-model.md        # Phase 1 output
├── quickstart.md        # Phase 1 output
├── contracts/           # Phase 1 output
│   └── task-operations.md
├── checklists/
│   └── requirements.md
└── tasks.md             # Phase 2 output (/sp.tasks command - NOT created by /sp.plan)
```

### Source Code (repository root)

```text
src/
├── models/
│   └── task.py              # Task entity with validation and lifecycle
├── services/
│   ├── task_store.py         # In-memory task storage and retrieval
│   ├── task_operations.py    # Business logic for CRUD, search, filter, sort
│   └── recurrence_engine.py  # Recurring task generation logic
├── cli/
│   ├── __init__.py
│   ├── main.py              # Application entry point
│   ├── commands.py          # CLI command handlers
│   ├── menu.py              # Menu-driven interface (if chosen)
│   └── formatter.py        # Output formatting and display
└── utils/
    ├── validators.py         # Input validation
    └── datetime_parser.py   # Date/time parsing and validation

tests/
├── unit/
│   ├── test_task_model.py
│   ├── test_task_store.py
│   ├── test_task_operations.py
│   ├── test_recurrence_engine.py
│   └── test_validators.py
└── integration/
    └── test_cli_workflow.py

pyproject.toml              # UV-managed project configuration
README.md                   # Setup and usage instructions
```

**Structure Decision**: Single project structure selected because Phase I is a CLI application with no frontend/backend separation. The layout follows Python best practices with clear module boundaries: models (domain entities), services (business logic), cli (interface), and utils (shared utilities). This structure is modular and extensible, allowing future phases to extract persistence layer (Phase II), API layer (Phase II), and MCP tools (Phase III) without rewriting core domain logic.

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

No constitution violations to justify. All gates passed.

---

## Phase 0: Outline & Research

**Status**: Complete (no research needed)

**Decision**: No external research required. Phase I uses only Python standard library, and specification clearly defines all requirements. Constitution provides technology constraints. All architectural decisions are straightforward and do not require external best practices research.

**Rationale**:
- Language, dependencies, and constraints are constitutionally defined
- Specification requirements are unambiguous (validated during spec creation)
- In-memory storage eliminates complexity of external systems
- CLI application patterns are well-established in Python ecosystem

**No research.md generated** - all technical context is known from constitution and specification.

---

## Phase 1: Design & Contracts

### 1.1 Data Model

**Output**: See [data-model.md](data-model.md)

The data model defines the core `Task` entity with all attributes from specification:
- ID (unique, auto-incrementing integer)
- Title (required, non-empty string)
- Description (optional string)
- Status (enum: complete/incomplete)
- Priority (enum: high/medium/low)
- Tags (set of strings)
- Due date (optional datetime)
- Reminder time (optional datetime)
- Recurrence rule (optional RecurrenceRule)

Validation rules are defined for each attribute, ensuring data integrity at model level.

### 1.2 Architecture Contracts

**Output**: See [contracts/task-operations.md](contracts/task-operations.md)

Architecture contracts define internal API boundaries between modules:
- **TaskStore**: In-memory storage interface (add, get, delete, update, list)
- **TaskOperations**: Business logic interface (search, filter, sort, mark_complete)
- **RecurrenceEngine**: Recurring task generation interface (calculate_next_occurrence)
- **CLIFormatter**: Output formatting interface (format_task, format_list, format_error)

These contracts establish clear module boundaries and enable independent testing and future refactoring.

### 1.3 Quick Start Guide

**Output**: See [quickstart.md](quickstart.md)

Quick start guide provides setup and usage instructions:
- Project setup using UV
- Running the application
- Basic task operations walkthrough
- Advanced features walkthrough (priorities, tags, search, filter, sort)
- Recurring tasks and reminders usage

---

## Phase 2: Execution Plan

### Step 1: Project Initialization & Structure

**Specification Reference**: FR-027, FR-029, FR-030

**Objective**: Establish a clean, extendable structure with clear responsibility boundaries.

**Implementation Approach**:
1. Create project root structure (src/, tests/, pyproject.toml)
2. Set up UV-managed Python 3.13+ environment
3. Create module stub files with docstrings defining responsibilities
4. Define module-level interfaces (TaskStore, TaskOperations, CLIFormatter)
5. Set up basic CLI entry point with help/usage information

**Validation**: Application runs and displays help message; module structure matches plan.

---

### Step 2: Domain Model Definition

**Specification Reference**: FR-001, FR-002, FR-007, FR-008, FR-016, FR-018, FR-020

**Objective**: Create a stable domain foundation with in-memory Task entity representation, validation rules, and lifecycle management.

**Implementation Approach**:
1. Implement Task model class with all attributes from specification
2. Define enums for Status (complete/incomplete) and Priority (high/medium/low)
3. Implement validation for required fields (title non-empty)
4. Implement validation for optional fields (priority values, date formats)
5. Implement ID generation (auto-incrementing integer starting at 1)
6. Define RecurrenceRule dataclass for recurrence patterns (daily, weekly, custom_interval)

**Validation**: Task instances can be created with valid and invalid inputs; validation errors are raised appropriately; IDs are unique and increment sequentially.

---

### Step 3: Core Task Management Operations

**Specification Reference**: FR-001 through FR-006, FR-023, FR-026

**Objective**: Deliver full Basic Level functionality (add, delete, update, view, mark complete).

**Implementation Approach**:
1. **TaskStore Service**: Implement in-memory storage using dict/list with methods:
   - add(task) -> Task (adds to storage, assigns ID)
   - get(id) -> Task | None
   - delete(id) -> bool (returns True if deleted, False if not found)
   - update(id, **fields) -> Task | None
   - list_all() -> list[Task]

2. **TaskOperations Service**: Implement business logic:
   - create_task(title, **fields) -> Task
   - delete_task(id) -> bool
   - update_task(id, **fields) -> Task | None
   - get_all_tasks() -> list[Task]
   - toggle_complete(id) -> Task | None

3. **CLI Integration**: Wire TaskOperations to CLI commands with error handling:
   - Add task command
   - Delete task command
   - Update task command
   - List tasks command
   - Mark complete command

**Validation**: All basic operations work through CLI; invalid IDs produce clear error messages; tasks persist in memory during runtime.

---

### Step 4: Organization & Usability Features

**Specification Reference**: FR-007 through FR-015, FR-023 through FR-026

**Objective**: Deliver Intermediate Level usability (priorities, tags, search, filter, sort).

**Implementation Approach**:
1. **TaskOperations Enhancement**: Extend service with organization methods:
   - search_tasks(keyword) -> list[Task] (searches title and description)
   - filter_by_status(status) -> list[Task]
   - filter_by_priority(priority) -> list[Task]
   - filter_by_due_date(has_due_date) -> list[Task]
   - sort_by_due_date(ascending=True) -> list[Task]
   - sort_by_priority(ascending=False) -> list[Task]
   - sort_by_title(ascending=True) -> list[Task]

2. **CLI Integration**: Wire organization methods to CLI commands:
   - Search command with keyword argument
   - Filter commands (status, priority, due_date)
   - Sort commands (due_date, priority, title)
   - Combine filter and sort (chain operations)

**Validation**: Search returns tasks with matching keywords; filters correctly apply criteria; sort returns ordered lists; combinations work correctly (e.g., filter by status then sort by priority); empty results display appropriate message.

---

### Step 5: Intelligent Features (Phase I Safe)

**Specification Reference**: FR-016 through FR-022, FR-019

**Objective**: Deliver Advanced Level features (due dates, reminders, recurring tasks) without background services.

**Implementation Approach**:
1. **Datetime Parsing Utility**: Implement robust date/time parsing:
   - Parse due dates from user input (supports common formats: YYYY-MM-DD, MM/DD/YYYY)
   - Parse reminder times from user input (supports HH:MM, HH:MM AM/PM)
   - Validate due date is after creation date
   - Validate reminder time is before or at due date

2. **RecurrenceEngine Service**: Implement recurring task generation:
   - RecurrenceRule dataclass (type: daily|weekly|custom, interval_days: int)
   - calculate_next_occurrence(current_task) -> Task
   - For daily: increment due date by 1 day
   - For weekly: increment due date by 7 days
   - For custom: increment by interval_days
   - Preserve all attributes except ID and recurrence metadata

3. **TaskOperations Enhancement**: Integrate recurrence:
   - Modified toggle_complete(id) -> Task checks for recurrence rule
   - If task has recurrence, generate new task and add to storage
   - Return the newly generated task

4. **Reminder System (Runtime-Only)**: Implement polling-based reminders:
   - Main loop checks for reminders every 5 seconds during idle time
   - find_due_reminders() -> list[Task] (tasks with reminder_time <= now and not notified)
   - display_reminder(task) -> prints formatted reminder to CLI
   - Mark reminders as notified to prevent duplicate notifications
   - Note: Reminders only trigger while application is running (per spec)

5. **Overdue Detection**: Implement status calculation:
   - is_overdue(task) -> bool (task.due_date < now and task.status == incomplete)
   - CLI formatter displays overdue indicator for overdue tasks

**Validation**: Due dates display correctly; overdue tasks are marked; reminders trigger during runtime; recurring tasks generate next occurrences on completion; reminder times before due dates work correctly.

---

### Step 6: CLI Interaction Design

**Specification Reference**: FR-027 through FR-030, SC-007, SC-008, SC-009

**Objective**: Ensure a usable and predictable CLI experience with clear error handling.

**Implementation Approach**:
1. **Menu-Driven Interface** (primary interaction mode):
   - Main menu with numbered options (1: Add Task, 2: View Tasks, 3: Mark Complete, etc.)
   - Sub-menus for complex operations (Update Task, Filter, Sort)
   - Clear prompts for user input
   - Input validation before executing operations
   - Return to main menu after each operation

2. **Command-Driven Interface** (alternative interaction mode):
   - Command-line arguments: `python -m cli add --title "Buy groceries" --priority high`
   - Subcommands: add, list, delete, update, complete, search, filter, sort
   - Help text for each command: `python -m cli add --help`
   - Error messages for invalid arguments or missing required fields

3. **Input Validation Strategy**:
   - Validators utility module with functions:
     - validate_title(title) -> raises ValueError if empty
     - validate_priority(priority) -> raises ValueError if not high/medium/low
     - validate_date(date_str) -> datetime or ValueError
     - validate_tags(tags) -> raises ValueError if invalid format
   - CLI catches validation errors and displays user-friendly messages
   - Example: "Invalid priority 'urgent'. Allowed values: high, medium, low"

4. **Output Formatting**:
   - CLIFormatter utility module with functions:
     - format_task(task) -> formatted string with all attributes
     - format_list(tasks) -> formatted table with headers
     - format_error(message) -> consistently formatted error prefix "ERROR: "
     - format_reminder(task) -> distinct reminder formatting
   - Consistent output across all views (list, search results, filtered views)
   - Visual indicators: ✓ for complete, ✗ for incomplete, ⚠ for overdue

5. **Error Handling Approach**:
   - All exceptions caught at CLI level
   - Specific error messages for each failure type:
     - Invalid task ID: "Task #999 not found. Available IDs: 1, 2, 3"
     - Invalid date: "Invalid date format 'next week'. Use YYYY-MM-DD or MM/DD/YYYY"
     - Empty task list: "No tasks found. Use 'Add Task' to create your first task."
   - System never crashes; always returns to main menu or command prompt

**Validation**: Menu interface navigates correctly; command-line interface works with help text; error messages are clear and actionable; output is consistently formatted across all operations.

---

### Step 7: Quality & Stability Review

**Specification Reference**: Edge Cases (spec.md lines 93-103), SC-001 through SC-009

**Objective**: Ensure correctness and extensibility through manual validation of all features and edge cases.

**Implementation Approach**:
1. **Unit Test Coverage**:
   - test_task_model.py: Task creation, validation, ID generation
   - test_task_store.py: Add, get, delete, update, list operations
   - test_task_operations.py: Search, filter, sort, recurrence
   - test_recurrence_engine.py: Daily, weekly, custom recurrence calculation
   - test_validators.py: Input validation edge cases

2. **Integration Test Coverage**:
   - test_cli_workflow.py: End-to-end CLI workflows
   - Full task lifecycle: create -> view -> update -> complete -> delete
   - Organization workflow: create multiple tasks -> filter -> sort -> search
   - Advanced workflow: recurring task with due date and reminder

3. **Edge Case Validation** (from spec):
   - Empty title input: Validation rejects with clear error message
   - Invalid priority value: Validation rejects with allowed values listed
   - Invalid date format: Date parser suggests valid formats
   - Filter matches zero tasks: Displays "No tasks match the criteria"
   - Sort with no applicable key: Displays "Sort not applicable (no tasks have due dates)"
   - Recurring task without due date: Generates task with same date attributes
   - Search with special characters: Escapes and searches correctly
   - Tags with spaces: Trims whitespace, preserves multi-word tags
   - Zero tasks list: View command displays "No tasks found"

4. **Performance Validation**:
   - Measure CRUD operation time for 100 tasks (< 1 second)
   - Measure search/filter/sort time for 100 tasks (< 1 second)
   - Measure reminder notification latency (< 5 seconds)

5. **Extensibility Review**:
   - Verify domain model can be extended with persistence layer (Phase II)
   - Verify CLI interface can be replaced with web UI (Phase II)
   - Verify TaskOperations can be wrapped as MCP tools (Phase III)
   - Verify code follows modular principles for future refactoring

**Validation**: All unit tests pass; integration tests pass; all edge cases handle gracefully; performance targets met; code is modular and extensible for future phases.

---

## Dependencies & Ordering

**Execution Order**: Steps 1 → 2 → 3 → 4 → 5 → 6 → 7

**Dependencies**:
- Step 2 depends on Step 1 (module structure must exist)
- Step 3 depends on Step 2 (Task model must exist)
- Step 4 depends on Step 3 (TaskOperations must exist)
- Step 5 depends on Step 3 (TaskOperations and Task model must exist)
- Step 6 depends on Steps 3, 4, 5 (all services must exist)
- Step 7 depends on all previous steps (complete implementation required)

**Stability Checkpoints**:
- After Step 2: Task model is stable with validation
- After Step 3: Basic CRUD operations work end-to-end
- After Step 4: Organization features work independently
- After Step 5: Advanced features integrate correctly
- After Step 6: CLI is usable with error handling
- After Step 7: Application is production-ready for Phase I

**No Step May**: Introduce features explicitly marked as out-of-scope (web UI, databases, authentication, cloud services).

---

## Deliverables

At the end of Phase I planning:

- **Complete Roadmap**: Seven sequential steps covering all specification requirements
- **Clear Mapping**: Each step references specific functional requirements (FR-001 through FR-030)
- **Modular Architecture**: Clear separation of concerns (models, services, cli, utils)
- **Traceability**: Every implementation action traces to spec section and constitution principle
- **Extensibility**: Design enables future phases to add persistence, web UI, and AI integration without rewriting core logic
- **Ready for Tasks**: Plan is detailed enough to convert into testable, executable tasks.md

---

## Traceability

Every future task:

- **MUST map to one plan step** (Step 1 through Step 7)
- **MUST reference originating specification section** (FR-XXX requirement)
- **MUST comply with constitution** (technology stack, modular design, no manual code)
- **MUST NOT introduce out-of-scope features** (databases, web UI, authentication, cloud)

**Example Traceability**:
- Task: "Implement Task model with validation" → Step 2 → FR-001, FR-002, FR-007, FR-008 → Constitution: Modular Design
- Task: "Implement search functionality" → Step 4 → FR-009 → Constitution: Production-Grade Engineering
- Task: "Implement recurrence engine" → Step 5 → FR-020, FR-021 → Constitution: Clean Folder Structure

---

## Architectural Decision Notes

**No ADRs Required**: All architectural decisions are straightforward and align with constitutional principles. The following decisions are documented here for traceability:

1. **In-Memory Storage**: Chosen because specification explicitly forbids databases and persistence. This simplifies Phase I and isolates storage concerns for future refactoring in Phase II.

2. **Menu-Driven CLI (Primary)**: Chosen over command-driven for better user experience. Menu interface is more discoverable for new users, which aligns with SC-008 (new user completes first task in 3 minutes). Command-driven interface is provided as alternative for power users.

3. **Polling-Based Reminders**: Chosen over event-driven reminders because specification explicitly forbids background services (Phase I non-goal). Polling every 5 seconds during idle time satisfies FR-019 within the 5-second SLA (SC-006) without violating constraints.

4. **Recurrence on Completion**: Chosen over scheduled generation because specification states "automatically generate the next occurrence in memory when the current task is marked complete" (FR-021). This is simpler than background scheduling and aligns with no-background-services constraint.

5. **Module Separation (models/services/cli/utils)**: Chosen to satisfy constitutional requirement for modular design. This separation enables future phases to swap CLI for web UI (Phase II), add persistence layer (Phase II), and wrap services as MCP tools (Phase III) without rewriting domain logic.

---

## Next Steps

**Proceed to**: `/sp.tasks` to convert this plan into testable, executable tasks.

**Prerequisites**:
- Phase 1 artifacts must be generated (data-model.md, contracts/task-operations.md, quickstart.md)
- Agent context must be updated with Python CLI patterns
- All constitutional gates must pass (already verified)

**Output of /sp.tasks**:
- tasks.md with task definitions for each implementation step
- Task-level acceptance criteria
- Dependencies and ordering between tasks
- File creation and modification checklist
