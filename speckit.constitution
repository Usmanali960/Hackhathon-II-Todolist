# Hackathon II: The Evolution of Todo - Project Constitution

## 1. Purpose & Vision

This project exists to demonstrate the complete evolution of a software application from a simple in-memory prototype to a production-ready, cloud-native, AI-driven system. The purpose is to showcase the transition from traditional syntax writing to AI-native system architecture, where AI agents serve as the primary engineers under human architectural guidance.

The vision is to master AI-native, cloud-native, spec-driven engineering principles through hands-on implementation of a Todo application across five evolutionary phases. Each phase represents a deliberate step toward building systems that are scalable, maintainable, and ready for enterprise deployment while maintaining full traceability from requirements to implementation.

## 2. Core Development Principles (Non-Negotiable)

**No Manual Application Code**: Humans MUST NOT write application code. All application code MUST be generated by Claude Code based on approved specifications. Humans may provide requirements, architectural decisions, and review outputs, but MUST NOT implement features directly.

**Specification-First**: All code MUST originate from approved specifications (spec.md → plan.md → tasks.md). No code may be written without a corresponding specification document defining requirements, constraints, and acceptance criteria.

**Claude Code as Sole Executor**: Claude Code is the ONLY authorized code-generating executor. No other AI or human may generate application code without explicit architectural override and documented justification.

**Single Source of Truth**: Specifications are the authoritative source of truth for all development work. When code and specifications conflict, specifications prevail. Code must be updated to match specifications, never the reverse.

**No Vibe Coding**: Prohibition against "vibe coding", improvisation, or undocumented changes. Every change must be traceable to a specific requirement, task, or architectural decision. No experimental or exploratory code may enter the codebase without being captured in the specification lifecycle.

**Incremental Validation**: Each phase MUST complete with a working, testable application before proceeding to the next phase. No phase may be skipped or combined without documented architectural rationale.

## 3. Spec-Driven Development Law

**Mandatory Lifecycle**: Constitution → Specify → Plan → Tasks → Implement

### Constitution
- **Responsibility**: Defines non-negotiable principles, technology constraints, and governance rules for the entire project lifecycle
- **Allowed**: Definition of architectural principles, technology stack locks, agent behavior rules, and success criteria
- **Forbidden**: Implementation details, feature-specific requirements, technology changes without governance process
- **Stop Condition**: Agents MUST stop if constitutional principles conflict with implementation approach; MUST request constitution amendment before proceeding

### Specify
- **Responsibility**: Defines feature requirements, scope, acceptance criteria, and constraints for each phase
- **Allowed**: Functional requirements, user stories, technical constraints, success metrics, phase boundaries
- **Forbidden**: Implementation details, technology choices, architectural decisions
- **Stop Condition**: Agents MUST stop if requirements are incomplete, ambiguous, or undefined; MUST request clarification from human architect

### Plan
- **Responsibility**: Defines architectural decisions, data models, API contracts, and deployment strategy
- **Allowed**: System architecture, service boundaries, database schema, API specifications, deployment topology
- **Forbidden**: Implementation logic, code structure, specific algorithms
- **Stop Condition**: Agents MUST stop if architectural decisions violate constitutional principles or specification requirements

### Tasks
- **Responsibility**: Breaks down the plan into testable, executable tasks with dependencies and acceptance criteria
- **Allowed**: Task definitions, test cases, implementation order, file creation, configuration changes
- **Forbidden**: Code implementation (only definitions)
- **Stop Condition**: Agents MUST stop if tasks are not traceable to plan or specification items

### Implement
- **Responsibility**: Executes tasks to produce code, tests, and deployment artifacts
- **Allowed**: Code generation, test creation, configuration updates, documentation generation
- **Forbidden**: Feature invention, specification modification without approval, architectural deviation
- **Stop Condition**: Agents MUST stop if required specifications, plans, or tasks are missing or incomplete

## 4. Agent Behavior Rules

**No Code Without Task ID**: All AI agents (Claude Code, Copilot, Gemini, MCP-connected agents) MUST NOT generate application code without a valid Task ID referencing an approved tasks.md entry. Code generated without task reference is invalid and MUST be rejected.

**No Architecture Without Plan Update**: Agents MUST NOT make architecture changes without updating the corresponding plan.md document. All architectural deviations must be documented, justified, and approved before implementation.

**No Feature Invention**: Agents MUST NOT invent, assume, or infer features beyond those defined in specifications. When requirements are ambiguous, agents MUST request clarification instead of guessing or making assumptions.

**Reference Spec Sections**: All agent outputs MUST reference relevant specification sections (e.g., "Per spec.md section 3.2..."). Code changes must be traceable to specific requirements, acceptance criteria, or constraints.

**Clarification Over Guessing**: When encountering ambiguity, missing requirements, or undefined behavior, agents MUST explicitly request clarification from the human architect. Guessing or making assumptions is forbidden.

**Conflict Resolution**: When code conflicts with specifications or plans, agents MUST stop and flag the conflict for resolution. Agents MUST NOT silently implement workarounds or undocumented changes.

**Audit Trail**: All agent actions MUST be traceable through PHR (Prompt History Record) entries. Every significant operation, decision, or output must be logged for audit and review.

## 5. Technology Stack Constraints

### Phase I: In-Memory Python CLI Application
- **Core Stack**: Python 3.13+, UV (package manager)
- **Allowed Additions**: Standard library only, UV for dependency management
- **Forbidden**: External databases, web frameworks, cloud services

### Phase II: Full-Stack Web Application
- **Core Stack**: Next.js (App Router), FastAPI, SQLModel, Neon PostgreSQL, Better Auth
- **Allowed Additions**: React components, API client libraries, development tools
- **Forbidden**: Alternative frameworks (Django, Laravel, etc.), alternative databases (MySQL, MongoDB, etc.), alternative auth systems

### Phase III: AI-Powered Todo Chatbot
- **Core Stack**: OpenAI ChatKit, OpenAI Agents SDK, Official MCP SDK
- **Allowed Additions**: OpenAI API clients, MCP tool implementations
- **Forbidden**: Alternative AI frameworks, custom LLM wrappers, non-standard MCP implementations

### Phase IV: Local Kubernetes Deployment
- **Core Stack**: Docker, Minikube, Helm, kubectl-ai, kagent
- **Allowed Additions**: Kubernetes operators, monitoring tools, logging aggregators
- **Forbidden**: Alternative container runtimes, cloud-managed Kubernetes services

### Phase V: Cloud-Native Event-Driven System
- **Core Stack**: Kafka, Dapr, Managed Kubernetes (AKS / GKE / OKE)
- **Allowed Additions**: Service mesh, observability stack, CI/CD tools
- **Forbidden**: Alternative message brokers (RabbitMQ, SQS), alternative sidecar frameworks

### Technology Governance Rules
- **Core Stack Replacements**: NOT ALLOWED. Core technology replacements require constitutional amendment and documented justification.
- **Additions**: Allowed ONLY if additions do not replace or circumvent core tools. Additions must align with architectural principles and phase goals.
- **Version Constraints**: Specific versions may be locked in specifications. Upgrades require documented impact analysis and approval.
- **Dependency Minimization**: Minimal dependencies principle. Each addition must justify necessity and evaluate long-term maintenance impact.

## 6. Architecture & Quality Standards

**Stateless Backend Philosophy**: Backend services MUST be stateless wherever possible. State MUST be externalized to databases, caches, or external stores. This enables horizontal scaling, fault tolerance, and cloud-native deployment patterns.

**Cloud-Native Mindset**: All architectural decisions MUST consider cloud-native principles: scalability, observability, fault tolerance, automated deployment, and infrastructure as code. Design for scale from day one, even in early phases.

**Event-Driven Mindset**: Favor event-driven communication patterns over tight coupling. Services SHOULD communicate asynchronously via events, messages, or webhooks where appropriate. This enables loose coupling and system evolution.

**Clear Service Boundaries**: Services MUST have well-defined boundaries and contracts. Each service MUST be independently deployable, testable, and maintainable. Avoid monolithic service design where services are tightly coupled or share business logic.

**Scalability Expectations**: Design for horizontal scalability. Avoid architectural patterns that limit scale (stateful services, synchronous dependencies, single points of failure). Each phase should demonstrate progress toward production scalability.

**Resilience Expectations**: Implement resilience patterns: retries with backoff, circuit breakers, timeout handling, graceful degradation. Failure modes MUST be defined and tested. System MUST remain partially functional during partial failures.

**Clean Folder Structure**: Follow clear, consistent folder structure conventions:
- Logical separation of concerns (e.g., /api, /services, /models, /utils)
- Feature-based organization where appropriate
- Test files co-located with implementation or in mirrored test directory
- Configuration separated from code

**Modular Design**: Design for modularity and reusability. Components SHOULD be:
- Small and focused (single responsibility)
- Loosely coupled
- Highly cohesive internally
- Testable in isolation

**Production-Grade Engineering**: Apply production-grade standards even in early phases:
- Comprehensive error handling
- Structured logging with correlation IDs
- Security best practices from day one
- Performance-aware design (avoid N+1 queries, optimize hot paths)
- Documentation for public APIs and complex logic

## 7. Security & Data Rules

**JWT-Based Authentication**: Authentication MUST use JWT (JSON Web Tokens) or equivalent stateless authentication mechanism. Tokens MUST contain:
- User identity and roles
- Expiration timestamps
- Cryptographic signatures

**User Data Isolation**: User data MUST be strictly isolated. Multi-tenancy principles apply even for single-user applications:
- Every data access MUST include user context
- Queries MUST filter by user ID at the database level
- Cross-user data access MUST be forbidden and tested

**Secrets Management**: Secrets MUST be managed via environment variables or secret managers. Hard-coded secrets in code are FORBIDDEN. Secrets include:
- API keys (OpenAI, databases, third-party services)
- Database passwords
- JWT signing keys
- Cloud provider credentials

**Environment-Specific Configuration**: Configuration MUST be environment-specific (dev, staging, production). Use configuration files (.env files, config maps) that are NOT committed to version control. Validate required configuration at application startup.

**No Hard-Coded Credentials**: Never hard-code credentials, tokens, or keys in application code. Always inject via environment variables, secrets management systems, or secure configuration stores.

**Principle of Least Privilege**: All components MUST operate with the minimum necessary privileges:
- Database users have minimal required permissions (read-only for queries, write-only for inserts)
- Service accounts have scoped permissions
- Third-party integrations use limited-access tokens

**Input Validation**: All user inputs MUST be validated at API boundaries. Implement:
- Schema validation (type checking, format enforcement)
- Length limits and sanitization
- SQL injection prevention (parameterized queries mandatory)
- XSS prevention (output encoding)

**Auditing**: Security-relevant events MUST be logged:
- Authentication attempts (success and failure)
- Authorization failures
- Data access (read/write operations on sensitive data)
- Configuration changes

## 8. AI & MCP Governance

**MCP as Only Interface**: MCP (Model Context Protocol) tools are the ONLY authorized interface for AI agents to interact with application state. AI agents MUST NOT:
- Directly access databases
- Modify application files outside MCP tools
- Execute arbitrary commands
- Access operating system directly

**Stateless MCP Tools**: MCP tools MUST be stateless. Each tool invocation is independent and idempotent where possible. Tool implementations MUST:
- Not maintain internal state between invocations
- Accept all required context as parameters
- Return complete, self-contained results
- Handle concurrent requests safely

**No Direct Database Access**: AI agents MUST NOT access the database directly. All data access MUST go through:
- MCP tools that wrap database operations
- API endpoints that agents can call
- Well-defined data access interfaces

**Traceability Requirement**: All AI-initiated actions MUST be traceable and explainable:
- Every tool call MUST be logged with context (task ID, user ID, action type)
- AI decisions MUST be explainable in natural language
- Failed operations MUST include actionable error messages
- Audit trails MUST survive restarts and failures

**MCP Tool Contract**: Each MCP tool MUST define:
- Input schema (parameters, validation rules)
- Output schema (return types, structure)
- Error handling (error codes, messages)
- Rate limiting and throttling policies
- Authorization requirements (who can invoke)

**AI Agent Boundaries**: AI agents operate within defined boundaries:
- Can read specifications and plans
- Can invoke approved MCP tools
- Can generate code for approved tasks
- CANNOT modify constitutional principles or core architecture without approval

**Safe AI Tooling**: AI tool usage MUST follow safety principles:
- Review AI-generated code before deployment
- Test AI outputs thoroughly (unit tests, integration tests)
- Implement guardrails (validation, rate limits, human-in-the-loop for critical operations)
- Monitor AI agent behavior for anomalies

## 9. Cloud-Native & DevOps Principles

**Immutable Containers**: Containers MUST be immutable. Once built, containers SHOULD NOT be modified. Configuration changes require rebuilding containers, not patching running instances.

**Infrastructure as Code**: Infrastructure MUST be declarative and version-controlled:
- Kubernetes manifests stored in version control
- Helm charts define deployment contracts
- Infrastructure changes follow PR review process
- No manual infrastructure modifications in production

**Kubernetes as Control Plane**: Kubernetes is the deployment control plane. All deployments MUST use Kubernetes (or Minikube for local development). Direct application deployment is FORBIDDEN.

**Helm Charts as Contracts**: Helm charts act as deployment contracts. Each chart MUST define:
- Deployment specifications (replicas, resources, health checks)
- Service definitions (ports, types, selectors)
- Configuration values (environment variables, secrets)
- Dependency relationships between components

**Local Mirrors Production**: Local development environments MUST mirror production architecture:
- Use Minikube to simulate Kubernetes
- Use same container images locally and in production
- Test deployment pipelines locally
- Validate configuration parity across environments

**Declarative Configuration**: Prefer declarative over imperative configuration:
- Kubernetes manifests over kubectl commands
- Helm values files over ad-hoc parameter passing
- Configuration files over command-line arguments

**Observability First**: Observability MUST be built-in from the start:
- Structured logging with correlation IDs
- Metrics for key operations (latency, error rates, throughput)
- Distributed tracing for cross-service calls
- Health checks and readiness probes

**Continuous Integration**: All changes MUST go through CI/CD:
- Automated tests on every commit
- Build artifact generation (container images)
- Security scans (dependency vulnerabilities, secrets detection)
- Deployment to test environments

**Continuous Deployment**: Deployment MUST be automated and repeatable:
- Helm chart deployment with versioning
- Rollback capability for failed deployments
- Blue-green or canary deployment strategies where appropriate
- Zero-downtime deployment goals

## 10. Change Management & Conflict Resolution

**Strict Hierarchy**: Constitution > Specify > Plan > Tasks > Code

Higher-level documents ALWAYS override lower-level documents. This hierarchy is absolute and non-negotiable. When conflicts occur:
- Code must conform to Tasks
- Tasks must conform to Plan
- Plan must conform to Specify
- Specify must conform to Constitution

**Conflict Detection**: Agents MUST detect and report conflicts:
- If code contradicts tasks, reject implementation
- If tasks contradict plan, reject task generation
- If plan contradicts spec, reject plan generation
- If spec contradicts constitution, reject spec definition

**Conflict Resolution Process**:
1. Agent stops and flags the conflict
2. Agent identifies which documents are in conflict
3. Agent references constitutional principles at stake
4. Agent proposes resolution (update lower-level document or amend higher-level document)
5. Human architect approves resolution
6. Resolution is documented and versioned

**No Silent Assumptions**: Silent assumptions are FORBIDDEN. When agents encounter:
- Ambiguous requirements
- Missing specifications
- Undefined behavior
- Inconsistent documentation

Agents MUST explicitly surface the issue and request clarification. Guessing, inferring, or silently resolving conflicts is prohibited.

**Documentation of Changes**: All changes MUST be documented:
- Constitutional amendments: versioned, ratified, distributed
- Specification changes: tracked in spec.md history
- Plan updates: referenced in plan.md changelog
- Task modifications: noted in tasks.md

**Change Authorization**: Changes require appropriate authorization:
- Constitution changes: architect approval + ratification process
- Specification changes: architect approval
- Plan changes: architect approval or documented justification
- Task changes: per project workflow (usually architect or tech lead)
- Code changes: per review process (automated or human)

**Rollback Capability**: Every change MUST be reversible:
- Code changes: version control (git revert, rollback)
- Configuration changes: previous versions in control
- Schema changes: migration rollback capability
- Infrastructure changes: Terraform/Helm rollback

## 11. Success Criteria

**Phase Completion**: Project success requires completion of ALL FIVE PHASES:
- Phase I: Working in-memory Python CLI application with full CRUD operations
- Phase II: Full-stack web application with Next.js frontend, FastAPI backend, PostgreSQL database, authentication
- Phase III: AI-powered chatbot interface using OpenAI Agents SDK, MCP tools for todo operations
- Phase IV: Kubernetes deployment with Docker containers, Helm charts, local Minikube environment
- Phase V: Cloud-native event-driven system with Kafka, Dapr sidecars, managed Kubernetes cluster

**Full Traceability**: Every line of code MUST be traceable back through the hierarchy:
- Code → Task ID in tasks.md
- Task → Design decision in plan.md
- Design → Requirement in spec.md
- Requirement → Principle in constitution

Traceability MUST be verified through automated or manual review before phase completion.

**Working Application at Each Checkpoint**: Each phase MUST deliver a WORKING APPLICATION:
- All features defined in phase spec are functional
- Tests pass (unit, integration, end-to-end)
- Deployment instructions work (local or cloud)
- Documentation is complete (README, API docs, architecture diagrams)

**Stateless, Scalable System**: Final system MUST demonstrate:
- Stateless backend architecture (no session state in application memory)
- Horizontal scalability (can add instances without code changes)
- Event-driven communication (services communicate via events/messages)
- Cloud-native deployment (Kubernetes, Helm, immutable containers)

**AI-Driven and Explainable**: System MUST be:
- AI-powered (natural language interface for todos)
- AI-explainable (every AI action has audit trail and rationale)
- AI-traceable (all AI operations logged and reviewable)
- AI-safe (guardrails, validation, human-in-the-loop for critical operations)

**Production-Ready Foundation**: Final system provides foundation suitable for startup evolution:
- Scalable architecture (handles 10x+ growth with minimal changes)
- Observable (logs, metrics, traces)
- Secure (authentication, authorization, secrets management)
- Maintainable (clean code, comprehensive tests, documentation)
- Deployable (CI/CD pipelines, automated deployment)

**Knowledge Transfer**: Project success includes captured knowledge:
- Complete documentation (architecture, deployment, operations)
- Runbooks (common operations, troubleshooting)
- Decision records (architectural decisions with rationale)
- PHR archive (full history of AI-human collaboration)
